syntax = "proto3";

package api.v1;

import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";
import "io/prometheus/client/metrics.proto";
import "api/v1/common.proto";

option go_package = "github.com/devzero-inc/services/dakr/gen/api/v1;gen";
option java_multiple_files = true;
option java_package = "gen.api.v1";

// EventType is a type of a event that can enter the system
enum EventType {
  EVENT_TYPE_UNSPECIFIED = 0;
  EVENT_TYPE_ADD = 1;
  EVENT_TYPE_UPDATE = 2;
  EVENT_TYPE_DELETE = 3;
  EVENT_TYPE_METADATA = 4;
  EVENT_TYPE_METRICS = 5;
  EVENT_TYPE_CONTAINER_STARTED = 6;
  EVENT_TYPE_CONTAINER_STOPPED = 7;
  EVENT_TYPE_CONTAINER_RESTARTED = 8;
  EVENT_TYPE_CLUSTER_SNAPSHOT = 9;
}

// ResourceType is a type of resource that can enter the system
enum ResourceType {
  RESOURCE_TYPE_UNSPECIFIED = 0;
  
  // Core Resources
  RESOURCE_TYPE_NODE = 1;
  RESOURCE_TYPE_POD = 2;
  RESOURCE_TYPE_NAMESPACE = 3;
  RESOURCE_TYPE_EVENT = 4;
  RESOURCE_TYPE_ENDPOINTS = 5;
  RESOURCE_TYPE_SERVICE_ACCOUNT = 6;
  RESOURCE_TYPE_LIMIT_RANGE = 7;
  RESOURCE_TYPE_RESOURCE_QUOTA = 8;
  
  // Workload Resources
  RESOURCE_TYPE_DEPLOYMENT = 9;
  RESOURCE_TYPE_STATEFUL_SET = 10;
  RESOURCE_TYPE_DAEMON_SET = 11;
  RESOURCE_TYPE_REPLICA_SET = 12;
  RESOURCE_TYPE_REPLICATION_CONTROLLER = 13;
  RESOURCE_TYPE_JOB = 14;
  RESOURCE_TYPE_CRON_JOB = 15;
  
  // Storage Resources
  RESOURCE_TYPE_PERSISTENT_VOLUME_CLAIM = 16;
  RESOURCE_TYPE_PERSISTENT_VOLUME = 17;
  RESOURCE_TYPE_STORAGE_CLASS = 18;
  
  // Networking Resources
  RESOURCE_TYPE_SERVICE = 19;
  RESOURCE_TYPE_INGRESS = 20;
  RESOURCE_TYPE_INGRESS_CLASS = 21;
  RESOURCE_TYPE_NETWORK_POLICY = 22;
  
  // RBAC Resources
  RESOURCE_TYPE_ROLE = 23;
  RESOURCE_TYPE_ROLE_BINDING = 24;
  RESOURCE_TYPE_CLUSTER_ROLE = 25;
  RESOURCE_TYPE_CLUSTER_ROLE_BINDING = 26;
  
  // Autoscaling Resources
  RESOURCE_TYPE_HORIZONTAL_POD_AUTOSCALER = 27;
  RESOURCE_TYPE_VERTICAL_POD_AUTOSCALER = 28;
  
  // Policy Resources
  RESOURCE_TYPE_POD_DISRUPTION_BUDGET = 29;
  RESOURCE_TYPE_POD_SECURITY_POLICY = 30;
  
  // Custom Resources
  RESOURCE_TYPE_CUSTOM_RESOURCE_DEFINITION = 31;
  RESOURCE_TYPE_CUSTOM_RESOURCE = 32;
  
  // Configuration Resources
  RESOURCE_TYPE_CONFIG_MAP = 33;
  RESOURCE_TYPE_SECRET = 34;
  
  // Container and Resource specific types
  RESOURCE_TYPE_CONTAINER = 35;
  RESOURCE_TYPE_NODE_RESOURCE = 36;
  RESOURCE_TYPE_CONTAINER_RESOURCE = 37;

  // Cluster resource - registration type
  RESOURCE_TYPE_CLUSTER = 38;

  // CSINode type
  RESOURCE_TYPE_CSI_NODE = 39;

  // Karpenter type
  RESOURCE_TYPE_KARPENTER = 40;

  // Datadog type
  RESOURCE_TYPE_DATADOG = 41;

  // Argo rollouts type
  RESOURCE_TYPE_ARGO_ROLLOUTS = 42;

  // Keda type - Leaving this as a reserve now, not really sure if we actually need it
  RESOURCE_TYPE_KEDA = 43;

  // Keda scaled object type
  RESOURCE_TYPE_KEDA_SCALED_OBJECT = 44;

  // Keda scaled job type
  RESOURCE_TYPE_KEDA_SCALED_JOB = 45;

  // CSI DRIVER 
  RESOURCE_TYPE_CSI_DRIVER = 46;

  // CSI STORAGE CAPACITY
  RESOURCE_TYPE_CSI_STORAGE_CAPACITY = 47;

  // VOLUME ATTACHMENT
  RESOURCE_TYPE_VOLUME_ATTACHMENT = 48;

  // KUBEFLOW NOTEBOOKS
  RESOURCE_TYPE_KUBEFLOW_NOTEBOOKS = 49;

  // Cluster snapshot type
  RESOURCE_TYPE_CLUSTER_SNAPSHOT = 77;
}

// ResourceItem contains the data for a single resource event.
message ResourceItem {
  // Unique identifier for the resource (optional, might be derived from data)
  string key = 1;

  // Timestamp when the resource was collected
  google.protobuf.Timestamp timestamp = 2;

  // Event type (add, update, delete, metrics, etc.)
  EventType event_type = 3;

  // The actual resource data as a flexible structure
  google.protobuf.Struct data = 4 [deprecated = true];

  // Type of resource (pod, container, node_resources, etc.)
  ResourceType resource_type = 5;

  // The actual resource data as a JSON string
  bytes data_bytes = 6;
}

// Requests
// SendRequest is used to push metrics for a single resource.
message SendResourceRequest {
  // Type of resource (pod, container, node_resources, etc.)
  ResourceType resource_type = 1;

  // Unique identifier for the resource
  string key = 2;

  // Timestamp when the resource was collected
  google.protobuf.Timestamp timestamp = 3;

  // Event type (add, update, delete, metrics, etc.)
  EventType event_type = 4;

  // The actual resource data as a flexible structure
  google.protobuf.Struct data = 5;

  // cluster_id of resource
  string cluster_id = 6;

  // team_id of resource
  string team_id = 7;
}

// SendResourceBatchRequest is used to push metrics for multiple resources of the same type.
message SendResourceBatchRequest {
  // The list of resources to process
  repeated ResourceItem resources = 1;

  // cluster_id of resources - all resources in the batch must belong to this cluster
  string cluster_id = 2;
  
  // team_id of resources - all resources in the batch must belong to this team
  string team_id = 3;
}

// Request for fetching minute-bucketed container forecast metrics
message GetForecastMetricsRequest {
  string cluster_id = 1;
  string namespace = 2;
  string workload_name = 3;
  string metric_type = 4;
  google.protobuf.Timestamp start_time = 5;
  google.protobuf.Timestamp end_time = 6;
}

// Response containing forecast metrics
message GetForecastMetricsResponse {
  repeated ContainerForecastMetric metrics = 1;
}

// Forecast metric for a container
message ContainerForecastMetric {
  google.protobuf.Timestamp timestamp = 1;
  string container_id = 2;
  string cluster_id = 3;
  string workload_name = 4;
  string namespace = 5;
  string metric_type = 6;
  double forecast_value = 7;
  double lower_bound = 8;
  double upper_bound = 9;
  string model_version = 10;
  google.protobuf.Timestamp created_at = 11;
  google.protobuf.Timestamp updated_at = 12;
}

// Responses
// Common response for all send operations
message SendResourceResponse {
  // Type of resource (pod, container, node_resources, etc.)
  ResourceType resource_type = 1;

  // Unique identifier for the cluster
  string cluster_identifier = 2;
}

// Response for batch send operations
message SendResourceBatchResponse {
  // Type of resource (pod, container, node_resources, etc.)
  ResourceType resource_type = 1;
  
  // Unique identifier for the cluster
  string cluster_identifier = 2;
  
  // Number of resources successfully processed
  int32 processed_count = 3;
}

// SendTelemetryMetricsRequest is used to send telemetry metrics from a cluster
message SendTelemetryMetricsRequest {
  // Unique identifier for the cluster
  string cluster_id = 1;
  
  // Collection of metrics
  repeated io.prometheus.client.MetricFamily metric_families = 2;
}

// SendTelemetryMetricsResponse is the response for telemetry metrics submission
message SendTelemetryMetricsResponse {
  // Unique identifier for the cluster
  string cluster_id = 1;
  
  // Number of metrics successfully processed
  int32 processed_count = 2;
}

// ClusterSnapshotChunk represents a chunk of cluster snapshot data
message ClusterSnapshotChunk {
  // Unique identifier for the cluster
  string cluster_id = 1;

  // Team ID that owns the cluster
  string team_id = 2;

  // Timestamp when the snapshot was taken
  google.protobuf.Timestamp timestamp = 3;

  // Unique identifier for this snapshot (same across all chunks)
  string snapshot_id = 4;

  // Chunk sequence number (starting from 0)
  int32 chunk_number = 5;

  // Total number of chunks in this snapshot
  int32 total_chunks = 6;

  // The chunk data as bytes
  bytes chunk_data = 7;

  // Indicates if this is the final chunk
  bool is_final_chunk = 8;
}

// Response for streaming cluster snapshot submission
message SendClusterSnapshotStreamResponse {
  // Unique identifier for the cluster
  string cluster_id = 1;

  // Unique identifier for the processed snapshot
  string snapshot_id = 2;

  // Status message
  string status = 3;

  // Number of chunks received
  int32 chunks_received = 4;

 // Contains resources that were not found in the database
  ClusterSnapshot missing_resources = 5;
}

// ResourceIdentifier contains minimal resource identification data
message ResourceIdentifier {
  string name = 1;
}

// NodeData represents a node with minimal data and assigned pod UIDs
message NodeData {
  ResourceIdentifier node = 1;
  map<string, ResourceIdentifier> pods = 2; // Maps UID to ResourceIdentifier
  string hash = 3;
}

// Namespace represents minimal namespace data with resource UIDs as keys
message Namespace {
  ResourceIdentifier namespace = 1;
  map<string, ResourceIdentifier> deployments = 2;
  map<string, ResourceIdentifier> stateful_sets = 3;
  map<string, ResourceIdentifier> daemon_sets = 4;
  map<string, ResourceIdentifier> replica_sets = 5;
  map<string, ResourceIdentifier> services = 6;
  map<string, ResourceIdentifier> config_maps = 7 [deprecated = true];
  map<string, ResourceIdentifier> secrets = 8;
  map<string, ResourceIdentifier> pvcs = 9;
  map<string, ResourceIdentifier> jobs = 10;
  map<string, ResourceIdentifier> cron_jobs = 11;
  map<string, ResourceIdentifier> ingresses = 12;
  map<string, ResourceIdentifier> network_policies = 13;
  map<string, ResourceIdentifier> service_accounts = 14;
  map<string, ResourceIdentifier> roles = 15;
  map<string, ResourceIdentifier> role_bindings = 16;
  map<string, ResourceIdentifier> pod_disruption_budgets = 17;
  map<string, ResourceIdentifier> endpoints = 18;
  map<string, ResourceIdentifier> limit_ranges = 19;
  map<string, ResourceIdentifier> resource_quotas = 20;
  map<string, ResourceIdentifier> unscheduled_pods = 21;
  map<string, ResourceIdentifier> horizontal_pod_autoscalers = 22;
  map<string, ResourceIdentifier> events = 23 [deprecated = true];
  map<string, ResourceIdentifier> keda_scaled_jobs = 24;
  map<string, ResourceIdentifier> keda_scaled_objects = 25;
  string hash = 26;
  map<string, ResourceIdentifier> csi_storage_capacities = 27;
}

// ClusterScopedSnapshot contains minimal cluster-scoped resource data
message ClusterScopedSnapshot {
  map<string, ResourceIdentifier> persistent_volumes = 1;
  map<string, ResourceIdentifier> storage_classes = 2;
  map<string, ResourceIdentifier> cluster_roles = 3;
  map<string, ResourceIdentifier> cluster_role_bindings = 4;
  map<string, ResourceIdentifier> custom_resource_definitions = 5;
  map<string, ResourceIdentifier> ingress_classes = 6;
  map<string, ResourceIdentifier> csi_nodes = 7;
  string hash = 8;
  map<string, ResourceIdentifier> csi_drivers = 9;
  map<string, ResourceIdentifier> volume_attachments = 10;
}

// ClusterInfo contains basic cluster information
message ClusterInfo {
  string version = 1;
  int32 node_count = 2;
  repeated string namespaces = 3;
}

// ClusterSnapshot represents a minimal snapshot for deletion tracking
message ClusterSnapshot {
  ClusterInfo cluster_info = 1;
  map<string, NodeData> nodes = 2; // Maps node UID to NodeData
  map<string, Namespace> namespaces = 3; // Maps namespace UID to Namespace
  ClusterScopedSnapshot cluster_scoped = 4;
  google.protobuf.Timestamp timestamp = 5;
  string snapshot_id = 6;
}

// LogLevel defines severity levels for log messages
enum LogLevel {
  LOG_LEVEL_UNSPECIFIED = 0;
  LOG_LEVEL_DEBUG = 1;
  LOG_LEVEL_INFO = 2;
  LOG_LEVEL_WARN = 3;
  LOG_LEVEL_ERROR = 4;
  LOG_LEVEL_FATAL = 5;
}

// SendTelemetryLogsRequest is used to send a batch of log messages from a cluster
message SendTelemetryLogsRequest {
  // Unique identifier for the cluster
  string cluster_id = 1;

  // Team ID that owns the cluster
  string team_id = 2;

  // List of log entries
  repeated LogEntry logs = 3;
}

// LogEntry represents a single log message
message LogEntry {
  // Timestamp of the log message
  google.protobuf.Timestamp timestamp = 1;

  // Severity level of the log
  LogLevel level = 2;

  // The actual log message
  string message = 3;

  // Structured fields associated with the log entry
  map<string, string> fields = 6;

  // Error string, if any
  string error = 7;

  // The source or component generating the log (e.g., pod name, container ID)
  string source = 11;
}

// SendTelemetryLogsResponse is the response for log ingestion
message SendTelemetryLogsResponse {
  // Number of logs successfully processed
  int32 processed_count = 1;
}

// Defines the service that provides RPC methods for Kubernetes cluster monitoring metrics collector.
service MetricsCollectorService {
  // SendResource pushes a single metric for a resource.
  rpc SendResource(SendResourceRequest) returns (SendResourceResponse);
  
  // SendResourceBatch pushes multiple metrics for resources of the same type.
  rpc SendResourceBatch(SendResourceBatchRequest) returns (SendResourceBatchResponse);
  
  // SendTelemetryMetrics pushes a batch of telemetry metrics (gauges, counters, histograms) from a cluster.
  rpc SendTelemetryMetrics(SendTelemetryMetricsRequest) returns (SendTelemetryMetricsResponse);

  // SendClusterSnapshotStream processes cluster snapshot data in chunks via streaming
  rpc SendClusterSnapshotStream(stream ClusterSnapshotChunk) returns (SendClusterSnapshotStreamResponse);

  // SendTelemetryLogs ingests a batch of log messages from the cluster.
  rpc SendTelemetryLogs(SendTelemetryLogsRequest) returns (SendTelemetryLogsResponse);

  rpc NodeMetadata(NodeMetadataRequest) returns (NodeMetadataResponse);
}

message NodeMetadataRequest {
    string team_id = 1; // Unique identifier for the team.
    string cluster_id = 2; // Unique identifier for the cluster.
}

message NodeMetadataResponse {
    map<string, Node> node_to_meta = 1; // map is node name to node
}
